#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           backRight,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           climb,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           armRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           wristRotate,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           armLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           frontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port10,          backLeft,      tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* --------------------------------------------------------------------------- */
/*                               Description:                                  */
/*                                                                             */
/*    This is the source code for Spudnik 1, a robot programmed by the El      */
/*    Segundo High School P.O.T.A.T.O.E.S. for the 2018-2019 VEX Turning Point */
/*    competition.                                                             */
/*                                                                             */
/*    The robot is designed as a holonomic Mecanum drive with strafing         */
/*    controlled by the left joystick (Ch3/Ch4) and turning controlled by the  */
/*    horizontal axis of the right joystick (Ch1).  The drive is driven by     */
/*    five 393 motors (one for each wheel, plus one more motor for the         */
/*    climbing wheels at the bottom of the robot).                             */
/*                                                                             */
/*    To overcome joystick sensitivity issues, the holonomic drive allows for  */
/*    a "deadzone" threshold; any values the joystick gives us below that      */
/*    will be ignored.                                                         */
/*                                                                             */
/*    The main feature of the robot is its arm, a double-reverse four-bar arm  */
/*    lift driven by two 393 motors.  We use an additional 393 motor at the    */
/*    end of the arm to articulate the "wrist" up and down, another to rotate  */
/*    the "wrist" clockwise and counterclockwise, and one final motor to       */
/*    control the gripping claw at the end of the wrist, giving us a grand     */
/*    total of 10 motors.                                                      */
/* --------------------------------------------------------------------------- */

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

// Main competition background code... do not modify!
#include "Vex_Competition_Includes.c"

/********************/
/* GLOBAL VARIABLES */
/********************/
int gyroAngle = 0;

// These variables control acceleration of the robot's drive.
float realLeftRight = 0.0;
float realForwardBack = 0.0;
float realTurn = 0.0;
const float ACCELERATION = 0.1;

// At all times, the four main drive motors and the wrist rotation
// motor will travel at this many times their natural speed.  The user
// can voluntarily reduce this value, causing the robot to make finer
// wrist rotation and drive movements until they release the precision
// button.
float precisionFactor = 1.0;

// Claw and wrist variables.
const int WRIST_ROTATE_SPEED = 40;

// ------------------------------------------------------------------------------
// Constants and variables used for the rotate() task.

// Before calling task rotate(), you should set this variable to a value
// between 0 and 359 degrees.
float targetOrientationDegrees = 0;

// ------------------------------------------------------------------------------
// Constants and variables used for the driveStraight() task.

// How close do we need to be to the target angle before our rotation slows down?
const float ROTATE_SLOWDOWN_THRESHOLD_DEGREES = 15;

// How fast to drive in a straight line.  This should be grater than
// (say) 30 and less than 128.
const float DRIVE_STRAIGHT_MAX_SPEED = 127;

// Our target traveling distance, in inches.  If this is less than 0, it is
// ignored.
//
// Before calling task driveStraight(), unless you intend for the robot to
// drive forever absent human intervention, you should set this variable to a
// non-negative value.  driveStraight() will then attempt to travel that many
// inches and no more.
float targetDistanceInches = -1;

// A conversion factor mapping distance traveled...
// - ...By the Spudnik 1's Mecanum wheels,
// - ...At the Spudnik 1's voltage level as it was during our measurement,
// - ...On the soft foam surface that we drove the robot on,
// - ...With the robot's weight at the time of the measurement
// ...to encoder clicks.
// ----------------------------------------------------------------------------
// 3000 clicks corresponds to this many inches of match floor driven
// by our Mecanum drive, according to trials taken on 2019-02-09:
//
// * (65 + 6/16) - 3
// * (64)        - 3
// * (64 + 6/16) - 3
// * (63 + 8/16) - 3
// * (63)        - 3
//
// This averages to 61.05 inches.  Note that these values were
// calculated with reduceSpeedIfNeeded() enabled
const float ENCODER_CLICKS_PER_INCH = 3000 / 61.05;

// At what point in our (targetDistanceInches)-inch journey should we
// start to slow down?
//
// Yes, this is 0.  It turns out that we brake so quickly that
// overshooting is not a significant concern.
const float DRIVE_STRAIGHT_STOPPING_DISTANCE_INCHES = 0.0;

// What is the decay factor we should use to diminish our speed once we reach
// the DRIVE_STRAIGHT_STOPPING_DISTANCE_INCHES?
const float DRIVE_STRAIGHT_SLOWDOWN_DECAY_FACTOR = 0.849;

// A flag that is true while driveStraight() is in progress and false otherwise.
bool stopped = true;

/*******************/
/* BASIC FUNCTIONS */
/*******************/

// Resets the encoder, must be done before every match
void clearEncoders() {
     nMotorEncoder[frontRight] = 0;
     nMotorEncoder[backRight] = 0;
     nMotorEncoder[backLeft] = 0;
     nMotorEncoder[frontLeft] = 0;
}

// WRIST ACTIONS
// Starts process of rotating wrist clockwise. Takes UNKNOWN seconds to
// complete and moves UNKONWN degrees
void rotateWristClockwise() {
     motor[wristRotate] = precisionFactor * WRIST_ROTATE_SPEED;
}

// Starts process of rotating wrist counterclockwise. Takes UNKNOWN
// seconds to complete and moves UNKONWN degrees
void rotateWristCounterClockwise() {
     motor[wristRotate] = precisionFactor * -WRIST_ROTATE_SPEED;
}

// Completely stops wrist rotation
void stopRotatingWrist() {
     motor[wristRotate] = 0;
}

// Starts the process of raising the arm.  The arm will not stop until
// lowerArm() or stopArm() is called.
//
// The arm takes about 5 seconds to raise in our tests, but the system
// provides no feedback when this is done, and it is possible to raise the arm
// with this function until the gears slip and the motor strains.  Take care!
void raiseArm() {
     motor[armRight] = 127;
     motor[armLeft] = 127;
}

// Starts the process of lowering the arm.  The arm will not stop until
// raiseArm() or stopArm() is called.
//
// See caveats and warnings in the documentation for raiseArm().
void lowerArm() {
     motor[armRight] = -127;
     motor[armLeft] = -127;
}

// Stops the arm from raising or lowering.
void stopArm() {
     motor[armRight] = 0;
     motor[armLeft] = 0;
}


/******************/
/* MECHANUM DRIVE */
/******************/
// Given a holonomic, 4-wheel Mecanum drive and three joystick values, this
// function moves the robot in the desired direction.
//
// To strafe left and right, simply provide a value for leftRight (and maybe
// forwardBack) without providing a value for the turning channel.
//
// Remember that this function provides instantaneous motion, and must be
// called in a loop to take place continuously.
//
// Arguments:
// - leftRight: The value sent by the left-right joystick channel (-127 for
//   full leftward motion and 127 for full rightward motion.)
//
//   This is usualy Ch3 on the left joystick.
//
// - forwardBack: The value sent by the forward-back joystick channel (-127
//   for full leftward motion and 127 for full rightward motion.)
//
//   This is usually Ch4 on the left joystick.
//
// - turn: The value sent by the turning joystick channel (-127 to turn left
//   at full speed and 127 to turn right at full speed.)
//
//   This is usually Ch1 on the right joystick.

void mecanumDrive(int leftRight, int forwardBack, int turn) {

     // Don't let the controller drive the motors directly.  Instead, the controller
     // represents the desired state, and we increment our way towards that.
     realLeftRight += sgn(leftRight - realLeftRight) * ACCELERATION;
     realForwardBack += sgn(forwardBack - realForwardBack) * ACCELERATION;
     realTurn += sgn(turn - realTurn) * ACCELERATION;

     if (leftRight < -127) {
          leftRight = -127;
     }
     if (leftRight > 127) {
          leftRight = 127;
     }
     if (forwardBack < -127) {
          forwardBack = -127;
     }
     if (forwardBack > 127) {
          forwardBack = 127;
     }

     if (turn < -127) {
          turn = -127;
     }
     if (turn > 127) {
          turn = 127;
     }

     motor[frontRight] = precisionFactor * (realForwardBack - realTurn - realLeftRight);
     motor[backRight] =  precisionFactor * (realForwardBack - realTurn + realLeftRight);
     motor[frontLeft] = precisionFactor * (realForwardBack + realTurn + realLeftRight);
     motor[backLeft] =  precisionFactor * (realForwardBack + realTurn - realLeftRight);

     // Determine when to activate the center climbing assistance wheels.
     motor[climb] = forwardBack;
}

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
     // Set bStopTasksBetweenModes to false if you want to keep user created tasks
     // running between Autonomous and Driver controlled modes. You will need to
     // manage all user created tasks if set to false.
     bStopTasksBetweenModes = true;

     // Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
     // used by the competition include file, for example, you might want
     // to display your team name on the LCD in this function.
     // bDisplayCompetitionStatusOnLcd = false;

     // All activities that occur before the competition starts
     // Example: clearing encoders, setting servo positions, ...

     // in order for the gyro to show the correct values, you must wait l0 mil
     // secs after sensorType = sensorNone, and 3500 mil secs after SensorType
     // = sensorGyro
     SensorType[in5] = sensorNone;
     wait1Msec(10);
     SensorType[in5] = sensorGyro;
     wait1Msec(3500);
}

// Floating-point modulus.  fmod(364.7, 360) = 4.7.
//
// This code comes to you courtesy of https://pastebin.com/Y1fUUnHi.
float fmod(float a, float b) { return a - b * floor(a/b); }

float min(float a, float b) {
	if (a > b){
		return b;
	}	else {
		return a;
	}
}

// Returns the smallest angle between the two given bearings using clever
// subtraction.
//
// Both bearings should be between 0 and 360 degrees.  The result ill be
// between -180 and +180 degrees.
//
// Code is from https://gamedev.stackexchange.com/a/4470 and is *untested*.
float angleBetween(float aDegrees, float bDegrees) {
    return min(fmod(aDegrees - bDegrees + 360, 360),
               fmod(bDegrees - aDegrees + 360, 360));
}

// This shows the current bearing given by the gyro without having to
// retype this every time the current bearing is mentioned.
float getCurrentBearing() {
		float currentBearing = SensorValue[in5] / 10.0;
		return currentBearing;
}

// An autonomous, asynchronous task whose only purpose is to rotate the robot
// toward a target orientation.
//
// Tasks don't take arguments.  Nonetheless, we do have one:
//
// - targetOrientationDegrees, a global variable that tells us at which
//   orientation we should stop rotating.

task rotate() {
		const float EPSILON = 0.01;

		// This value was chosen because it will slow down the speed of rotation without bringing
		// it to a complete stop too quickly.
		const float SLOWDOWN_CONSTANT = 0.9985;

		float speed = 127;
		float errorDegrees = 0;

    // Our goal is to minimize angleBetween(our current bearing, target bearing).
		do {

			errorDegrees = abs(angleBetween(getCurrentBearing(),
			                     						targetOrientationDegrees));

			// Rotate in a way that minimizes the angleBetween.
			mecanumDrive(0, 0, speed);

			// Slow down as we get closer to the target bearing.
			if (errorDegrees < ROTATE_SLOWDOWN_THRESHOLD_DEGREES) {
				speed = speed*SLOWDOWN_CONSTANT;
			}
		} while (errorDegrees > EPSILON);


}

// Uses the mecanumDrive() function to drive in set patterns, testing whether everything was wired correctly.
//
// Remember that this function provides instantaneous motion, and must be
// called in a loop to take place continuously.
//
// Arguments:
// - periodLengthMilliseconds: The duration of the programmed cycle of behavior.
//   Must be less than 32,767 (the maximum duration of the vex timers.)
//
// Return values:
// - True if we've reached the end of our cycle, false otherwise.  The cycle
//   will repeat itself again naturally unless you stop calling autonomousTest().
bool autonomousTest(int periodLengthMilliseconds) {

     float milliseconds = time1[timer1];
     if (milliseconds > periodLengthMilliseconds) {
          clearTimer(timer1);
          milliseconds = 0;
          nMotorEncoder[frontRight] = 0;

     }
     const float L = periodLengthMilliseconds;

     if (nMotorEncoder[frontRight] < 500) {
          mecanumDrive(0, 127, 0);

          return true;
     } else {
          // Stop.
          // startTask (brake);

          return false;
     }
}

// Helper function for task driveStraight().
//
// Ensures that the two given motors are traveling at the same _rate_,
// so that their encoder clicks match up, regardless of the load on
// either wheel.
//
// Once the encoder clicks are synced, this function then tries to
// ramp up the speeds of both motors until one of them has reached the
// desired speed.
//
// @param leftMotor    The index of the left motor to adjust.
// @param rightMotor   The index of the rightleft motor to adjust.
// @param desiredSpeed The speed that at least one motor should eventually
//                     have.  This should be between -127 and 127.
// @param maxSpeed     The maximum speed to apply to either motor.  This should
//                     be between -127 and 127.
// @param increment    The smallest amount by which to increment the motor
//                     speeds when adjusting.  Don't be afraid to use a larger
//                     value like 5.0 here; fine granularity just makes the
//                     adjustments slower.
void adjustMotorSpeeds(int leftMotor, int rightMotor, float desiredSpeed, float maxSpeed, float increment) {

     float leftSpeed = motor[leftMotor];
     float rightSpeed = motor[rightMotor];

     if (nMotorEncoder[leftMotor] < nMotorEncoder[rightMotor]) {

          // If the left motor is lagging behind right motor. Speed the left motor up...
          if (leftSpeed > maxSpeed) {
               // ...Unless it's already going as fast as possible, in which case we slow the _right_ motor down instead.
               rightSpeed -= increment;
          } else {
               leftSpeed += increment;
          }

     } else if (nMotorEncoder[leftMotor] > nMotorEncoder[rightMotor]) {

          // Right motor is lagging behind the left motor.  Speed the right motor up...
          if (rightSpeed > maxSpeed) {
               // ...Unless it's already going as fast as possible, in which case we slow the _left_ motor ow instead.
               leftSpeed -= increment;
          } else {
               rightSpeed += increment;
          }
     } else {
          // Motors are traveling at the same rate.
          if (leftSpeed < desiredSpeed || rightSpeed < desiredSpeed) {
               // But is the rate too low?
               leftSpeed += increment;
               rightSpeed += increment;
          } else if (leftSpeed > desiredSpeed || rightSpeed > desiredSpeed) {
               // But is the rate too high?
               leftSpeed -= increment;
               rightSpeed -= increment;
          }
     }

     motor[leftMotor] += leftSpeed;
     motor[rightMotor] += rightSpeed;
}

// Helper function for task driveStraight().
//
// Given a present speed, a motor whose encoders we will examine, and a target
// distance, calculates the "ideal" speed that should be applied to all of the
// motors (not just the one you passed in!) so that we are fully stopped by
// the time we hit the target distance.
//
// This function does not actually change the speed of the robot--it just
// returns the new speed that the robot _should_ have
float reduceSpeedIfNeeded(float currentSpeed, int motor, float targetDistanceInches) {

     // VEX 393 motors don't give any useful output below this speed.
     const float MIN_MOTOR_SPEED = 20.0;

     float speed                 = currentSpeed;
     float clicks                = nMotorEncoder[motor];
     float currentDistanceInches = clicks / ENCODER_CLICKS_PER_INCH;

     if (targetDistanceInches >= 0 &&
         currentDistanceInches > targetDistanceInches - DRIVE_STRAIGHT_STOPPING_DISTANCE_INCHES) {

          speed *= DRIVE_STRAIGHT_SLOWDOWN_DECAY_FACTOR;

          if (speed < MIN_MOTOR_SPEED) {
               speed = 0;
          }
     }
     return speed;
}

// An autonomous, asynchronous task whose only purpose is to drive the robot
// in a straight line.
//
// Tasks don't take arguments.  Nonetheless, we do have one:
//
// - targetDistanceInches, a global variable that, if non-negative, tells us
//   how far we should drive before quitting from this task.
//
// You can also quit from the task by pressing Btn8L (at least right now.)
task driveStraight() {
     stopped = false;
     clearEncoders();
     bool done = false;
     const float epsilon = 0.01;
     float speed = DRIVE_STRAIGHT_MAX_SPEED;

     motor[frontLeft]  = speed;
     motor[frontRight] = speed;
     motor[backRight]  = speed;
     motor[backLeft]   = speed;

     while(!done) {
          adjustMotorSpeeds(frontLeft,  frontRight, speed, 127, 10.0);
          adjustMotorSpeeds(backLeft,   backRight,  speed, 127, 10.0);
          speed = reduceSpeedIfNeeded(speed, frontLeft, targetDistanceInches);

          if (vexRT[Btn8L] > 0 || abs(speed) < epsilon) {
               done = true;
          }
     }
     stopped = true;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
     clearTimer(timer1);
     while (time1[timer1] < 3000)
     {
          mecanumDrive(0, 127, 0);
     }
     mecanumDrive(0,0,0);
     // ..........................................................................
     //nMotorEncoder[backRight] = 0;
     //while(nMotorEncoder[backRight] < "x")


     // ..........................................................................

     // Remove this function call once you have "real" code.
     //AutonomousCodePlaceholderForTesting();
}

// MECHANUM CONTROL
// Given a holonomic, 4-wheel Mecanum drive and three joystick channels, this
// function calls mecanumDrive() correctly to allow a human using those
// joysticks to drive the bot.
//
// Remember that this function provides instantaneous motion, and must be
// called in a loop to take place continuously.
//
// Arugments:
// - leftRightJoystickChannel: The channel that controls horizontal
//   strafing -- ordinarily Ch3 on the left joystick.
// - frontBackJoystickChannel: The channel that controls front-back
//   movement -- ordinarily Ch4 on the left joystick.
// - turnJoystickChannel: The channel that controls
//   counterclockwise/clockwise turning -- ordinarily Ch1 on the right joystick.
// - deadzoneThreshold: Any channel value whose aboslute value is less than this
//   will be ignored.  This compensates for the fact that joysticks sometimes
//   tend not to rest at perfect 0.
//   This variable will only have effect if it is non-negative.  Setting it too
//   high will make driving unresponsive and difficult.
void mecanumControl(int leftRightJoystickChannel, int frontBackJoystickChannel, int turnJoystickChannel, int deadzoneThreshold=15) {

     //Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
     int X2 = 0, Y1 = 0, X1 = 0;

     //Create "deadzone" for Y1/Ch3
     if(abs(vexRT[frontBackJoystickChannel]) > deadzoneThreshold)
          Y1 = vexRT[frontBackJoystickChannel];
     else
          Y1 = 0;

     //Create "deadzone" for X1/Ch4
     if(abs(vexRT[leftRightJoystickChannel]) > deadzoneThreshold)
          X1 = vexRT[leftRightJoystickChannel];
     else
          X1 = 0;

     //Create "deadzone" for X2/Ch1
     if(abs(vexRT[turnJoystickChannel]) > deadzoneThreshold)
          X2 = vexRT[turnJoystickChannel];
     else
          X2 = 0;

     mecanumDrive(X1, Y1, X2);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
     // User control code here, inside the loop

     int autonomousControl = 0;
     while (true)
     {
          gyroAngle = SensorValue[in5];
          //sync gyroAngle to gyroValue so that the gyroValue is shown during debugging
          // Button 7L begins "autonomous"
          if (vexRT[Btn7L] > 0) {
               // targetDistanceInches = 100.0;
               // startTask(driveStraight);
          		targetOrientationDegrees = 90;
          		startTask(rotate);
          }

          // If we're not driving in a square, the human can have a go.
          if (autonomousControl != 2) {
               //Remote Control Commands
               int threshold = 50;
               mecanumControl(Ch4, Ch3, Ch1, threshold);
          }

          ///////////////////
          // ARM ELEVATION //
          ///////////////////
          // While user presses button 5D then arm goes up, and while user presses
          // button 6D the arm goes down.
          if (vexRT[Btn5D] > 0) {
               raiseArm();
          } else if (vexRT[Btn6D] > 0) {
               lowerArm();
          } else {
               stopArm();
          }

          ////////////////////
          // WRIST ROTATION //
          ////////////////////
          // Buttons: 7D (counterclockwise), 7U (clockwise)

          if (vexRT[Btn7D] > 0) {
               rotateWristCounterClockwise();
          } else if (vexRT[Btn7U] > 0) {
               rotateWristClockwise();
          } else {
               stopRotatingWrist();
          }

          // PRECISION MODE
          // While button 5U is held down, the robot's drive and wrist rotation motors slow by 50%.
          if (vexRT[Btn5U] > 0) {
               precisionFactor = 0.5;
          } else {
               precisionFactor = 1.0;
          }

     } // end (while true)
} // end (task usercontrol)
