#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           backRight,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           climb,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           armRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           wristRotate,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           armLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           frontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port10,          backLeft,      tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* --------------------------------------------------------------------------- */
/*                               Description:                                  */
/*                                                                             */
/*    This is the source code for Spudnik 1, a robot programmed by the El      */
/*    Segundo High School P.O.T.A.T.O.E.S. for the 2018-2019 VEX Turning Point */
/*    competition.                                                             */
/*                                                                             */
/*    The robot is designed as a holonomic Mecanum drive with strafing         */
/*    controlled by the left joystick (Ch3/Ch4) and turning controlled by the  */
/*    horizontal axis of the right joystick (Ch1).  The drive is driven by     */
/*    five 393 motors (one for each wheel, plus one more motor for the         */
/*    climbing wheels at the bottom of the robot).                             */
/*                                                                             */
/*    To overcome joystick sensitivity issues, the holonomic drive allows for  */
/*    a "deadzone" threshold; any values the joystick gives us below that      */
/*    will be ignored.                                                         */
/*                                                                             */
/*    The main feature of the robot is its arm, a double-reverse four-bar arm  */
/*    lift driven by two 393 motors.  We use an additional 393 motor at the    */
/*    end of the arm to articulate the "wrist" up and down, another to rotate  */
/*    the "wrist" clockwise and counterclockwise, and one final motor to       */
/*    control the gripping claw at the end of the wrist, giving us a grand     */
/*    total of 10 motors.                                                      */
/* --------------------------------------------------------------------------- */

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

// Main competition background code... do not modify!
#include "Vex_Competition_Includes.c"

/********************/
/* GLOBAL VARIABLES */
/********************/
int gyroAngle = 0;
// These variables control acceleration of the robot's drive.
float realLeftRight = 0.0;
float realForwardBack = 0.0;
float realTurn = 0.0;
const float ACCELERATION = 0.1;

// At all times, the four main drive motors and the wrist rotation
// motor will travel at this many times their natural speed.  The user
// can voluntarily reduce this value, causing the robot to make finer
// wrist rotation and drive movements until they release the precision
// button.
float precisionFactor = 1.0;


// Claw and wrist variables.
const int WRIST_ROTATE_SPEED = 40;

/*******************/
/* BASIC FUNCTIONS */
/*******************/

//Resest the encoder, must be done before every match
void clearEncoders() {
    nMotorEncoder[frontRight] = 0;
    nMotorEncoder[backRight] = 0;
    nMotorEncoder[backLeft] = 0;
    nMotorEncoder[frontLeft] = 0;
}

// WRIST ACTIONS
// Starts process of rotating wrist clockwise. Takes UNKNOWN seconds to
// complete and moves UNKONWN degrees
void rotateWristClockwise() {
    motor[wristRotate] = precisionFactor * WRIST_ROTATE_SPEED;
}

// Starts process of rotating wrist counterclockwise. Takes UNKNOWN
// seconds to complete and moves UNKONWN degrees
void rotateWristCounterClockwise() {
    motor[wristRotate] = precisionFactor * -WRIST_ROTATE_SPEED;
}

// Completely stops wrist rotation
void stopRotatingWrist() {
    motor[wristRotate] = 0;
}

// Starts the process of raising the arm.  The arm will not stop until
// lowerArm() or stopArm() is called.
//
// The arm takes about 5 seconds to raise in our tests, but the system
// provides no feedback when this is done, and it is possible to raise the arm
// with this function until the gears slip and the motor strains.  Take care!
void raiseArm() {
    motor[armRight] = 127;
    motor[armLeft] = 127;
}

// Starts the process of lowering the arm.  The arm will not stop until
// raiseArm() or stopArm() is called.
//
// See caveats and warnings in the documentation for raiseArm().
void lowerArm() {
    motor[armRight] = -127;
    motor[armLeft] = -127;
}

// Stops the arm from raising or lowering.
void stopArm() {
    motor[armRight] = 0;
    motor[armLeft] = 0;
}


/******************/
/* MECHANUM DRIVE */
/******************/
// Given a holonomic, 4-wheel Mecanum drive and three joystick values, this
// function moves the robot in the desired direction.
//
// To strafe left and right, simply provide a value for leftRight (and maybe
// forwardBack) without providing a value for the turning channel.
//
// Remember that this function provides instantaneous motion, and must be
// called in a loop to take place continuously.
//
// Arguments:
// - leftRight: The value sent by the left-right joystick channel (-127 for
//   full leftward motion and 127 for full rightward motion.)
//
//   This is usualy Ch3 on the left joystick.
//
// - forwardBack: The value sent by the forward-back joystick channel (-127
//   for full leftward motion and 127 for full rightward motion.)
//
//   This is usually Ch4 on the left joystick.
//
// - turn: The value sent by the turning joystick channel (-127 to turn left
//   at full speed and 127 to turn right at full speed.)
//
//   This is usually Ch1 on the right joystick.

void mecanumDrive(int leftRight, int forwardBack, int turn) {

    // Don't let the controller drive the motors directly.  Instead, the controller
    // represents the desired state, and we increment our way towards that.
    realLeftRight += sgn(leftRight - realLeftRight) * ACCELERATION;
    realForwardBack += sgn(forwardBack - realForwardBack) * ACCELERATION;
    realTurn += sgn(turn - realTurn) * ACCELERATION;

    if (leftRight < -127) {
	leftRight = -127;
    }
    if (leftRight > 127) {
	leftRight = 127;
    }
    if (forwardBack < -127) {
	forwardBack = -127;
    }
    if (forwardBack > 127) {
	forwardBack = 127;
    }

    if (turn < -127) {
	turn = -127;
    }
    if (turn > 127) {
	turn = 127;
    }

    motor[frontRight] = precisionFactor * (realForwardBack - realTurn - realLeftRight);
    motor[backRight] =  precisionFactor * (realForwardBack - realTurn + realLeftRight);
    motor[frontLeft] = precisionFactor * (realForwardBack + realTurn + realLeftRight);
    motor[backLeft] =  precisionFactor * (realForwardBack + realTurn - realLeftRight);

    // Determine when to activate the center climbing assistance wheels.
    motor[climb] = forwardBack;
}

task brake()
{

    const int clicksToBrake = 20;
    int startClicks = nMotorEncoder[frontRight];

    while (abs(startClicks - nMotorEncoder[frontRight]) < clicksToBrake)
	{
	    mecanumDrive(0, -127, 0);
	}
    mecanumDrive(0, 0, 0);
}// end (task brake)

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
    SensorType[in5] = sensorNone;
    wait1Msec(10);
    SensorType[in5] = sensorGyro;
    wait1Msec(3500);
    //in order for the gyro to show the correct values, you must wair l0 mil secs after sensorType = sensorNone, and 3500 mil secs after SensorType = sensorGyro
    // Set bStopTasksBetweenModes to false if you want to keep user created tasks
    // running between Autonomous and Driver controlled modes. You will need to
    // manage all user created tasks if set to false.
    bStopTasksBetweenModes = true;

    // Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
    // used by the competition include file, for example, you might want
    // to display your team name on the LCD in this function.
    // bDisplayCompetitionStatusOnLcd = false;

    // All activities that occur before the competition starts
    // Example: clearing encoders, setting servo positions, ...
}

// Uses the mecanumDrive() function to drive in set patterns, testing whether everything was wired correctly.
//
// Remember that this function provides instantaneous motion, and must be
// called in a loop to take place continuously.
//
// Arguments:
// - periodLengthMilliseconds: The duration of the programmed cycle of behavior.
//   Must be less than 32,767 (the maximum duration of the vex timers.)
//
// Return values:
// - True if we've reached the end of our cycle, false otherwise.  The cycle
//   will repeat itself again naturally unless you stop calling autonomousTest().
bool autonomousTest(int periodLengthMilliseconds) {

    float milliseconds = time1[timer1];
    if (milliseconds > periodLengthMilliseconds) {
	clearTimer(timer1);
	milliseconds = 0;
	nMotorEncoder[frontRight] = 0;

    }
    const float L = periodLengthMilliseconds;

    if (nMotorEncoder[frontRight] < 500) {
	mecanumDrive(0, 127, 0);

	return true;
    } else {
	// Stop.
	startTask (brake);

	return false;
    }
}

// Helper function for task driveStraight().
//
// Ensures that the two given motors are traveling at the same _rate_,
// so that their encoder clicks match up, regardless of the load on
// either wheel.
//
// Once the encoder clicks are synced, this function then tries to
// ramp up the speeds of both motors until one of them has reached the
// desired speed.
//
// @param leftMotor    The index of the left motor to adjust.
// @param rightMotor   The index of the rightleft motor to adjust.
// @param desiredSpeed The speed that at least one motor should eventually
//                     have.  This should be between -127 and 127.
// @param maxSpeed     The maximum speed to apply to either motor.  This should
//                     be between -127 and 127.
// @param increment    The smallest amount by which to increment the motor
//                     speeds when adjusting.  Don't be afraid to use a larger
//                     value like 5.0 here; fine granularity just makes the
//                     adjustments slower.
void adjustMotorSpeeds(int leftMotor, int rightMotor, float desiredSpeed, float maxSpeed, float increment) {

    float leftSpeed = motor[leftMotor];
    float rightSpeed = motor[rightMotor];

    if (nMotorEncoder[leftMotor] < nMotorEncoder[rightMotor]) {

	// If the left motor is lagging behind right motor. Speed the left motor up...
	if (leftSpeed > maxSpeed) {
	    // ...Unless it's already going as fast as possible, in which case we slow the _right_ motor down instead.
	    rightSpeed -= increment;
	} else {
	    leftSpeed += increment;
	}

    } else if (nMotorEncoder[leftMotor] > nMotorEncoder[rightMotor]) {

	// Right motor is lagging behind the left motor.  Speed the right motor up...
	if (rightSpeed > maxSpeed) {
	    // ...Unless it's already going as fast as possible, in which case we slow the _left_ motor ow instead.
	    leftSpeed -= increment;
	} else {
	    rightSpeed += increment;
	}
    } else {
	// Motors are traveling at the same rate.
	if (leftSpeed < desiredSpeed || rightSpeed < desiredSpeed) {
	    // But is the rate too low?
	    leftSpeed += increment;
	    rightSpeed += increment;
	} else if (leftSpeed > desiredSpeed || rightSpeed > desiredSpeed) {
	    // But is the rate too high?
	    leftSpeed -= increment;
	    rightSpeed -= increment;
	}
    }

    motor[leftMotor] += leftSpeed;
    motor[rightMotor] += rightSpeed;
}


// Button press to drive robot in straight line
task driveStraight() {
    clearEncoders();
    bool done = false;
    float speed = 120;

    motor[frontLeft] = speed;
    motor[frontRight] = speed;
    motor[backRight] = speed;
    motor[backLeft] = speed;

    while(!done) {
	adjustMotorSpeeds(frontLeft, frontRight, 120, 127, 10.0);
	adjustMotorSpeeds(backLeft, backRight, 120, 127, 10.0);
	if (vexRT[Btn8L] > 0) {
	    done = true;
	}
    }
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
    clearTimer(timer1);
    while (time1[timer1] < 3000)
	{
	    mecanumDrive(0, 127, 0);
	}
    mecanumDrive(0,0,0);
    // ..........................................................................
    //nMotorEncoder[backRight] = 0;
    //while(nMotorEncoder[backRight] < "x")


    // ..........................................................................

    // Remove this function call once you have "real" code.
    //AutonomousCodePlaceholderForTesting();
}

// MECHANUM CONTROL
// Given a holonomic, 4-wheel Mecanum drive and three joystick channels, this
// function calls mecanumDrive() correctly to allow a human using those
// joysticks to drive the bot.
//
// Remember that this function provides instantaneous motion, and must be
// called in a loop to take place continuously.
//
// Arugments:
// - leftRightJoystickChannel: The channel that controls horizontal
//   strafing -- ordinarily Ch3 on the left joystick.
// - frontBackJoystickChannel: The channel that controls front-back
//   movement -- ordinarily Ch4 on the left joystick.
// - turnJoystickChannel: The channel that controls
//   counterclockwise/clockwise turning -- ordinarily Ch1 on the right joystick.
// - deadzoneThreshold: Any channel value whose aboslute value is less than this
//   will be ignored.  This compensates for the fact that joysticks sometimes
//   tend not to rest at perfect 0.
//   This variable will only have effect if it is non-negative.  Setting it too
//   high will make driving unresponsive and difficult.
void mecanumControl(int leftRightJoystickChannel, int frontBackJoystickChannel, int turnJoystickChannel, int deadzoneThreshold=15) {

    //Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
    int X2 = 0, Y1 = 0, X1 = 0;

    //Create "deadzone" for Y1/Ch3
    if(abs(vexRT[frontBackJoystickChannel]) > deadzoneThreshold)
	Y1 = vexRT[frontBackJoystickChannel];
    else
	Y1 = 0;

    //Create "deadzone" for X1/Ch4
    if(abs(vexRT[leftRightJoystickChannel]) > deadzoneThreshold)
	X1 = vexRT[leftRightJoystickChannel];
    else
	X1 = 0;

    //Create "deadzone" for X2/Ch1
    if(abs(vexRT[turnJoystickChannel]) > deadzoneThreshold)
	X2 = vexRT[turnJoystickChannel];
    else
	X2 = 0;

    mecanumDrive(X1, Y1, X2);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
    // User control code here, inside the loop

    int autonomousControl = 0;
    while (true)
	{
	    gyroAngle = SensorValue[in5];
	    //sync gyroAngle to gyroValue so that the gyroValue is shown during debugging
	    // Button 7L begins "autonomous"
	    if (vexRT[Btn7L] > 0) {
		startTask(driveStraight);
	    }

	    // If we're not driving in a square, the human can have a go.
	    if (autonomousControl != 2) {
		//Remote Control Commands
		int threshold = 50;
		mecanumControl(Ch4, Ch3, Ch1, threshold);
	    }

	    ///////////////////
	    // ARM ELEVATION //
	    ///////////////////
	    // While user presses button 5D then arm goes up, and while user presses
	    // button 6D the arm goes down.
	    if (vexRT[Btn5D] > 0) {
		raiseArm();
	    } else if (vexRT[Btn6D] > 0) {
		lowerArm();
	    } else {
		stopArm();
	    }

	    ////////////////////
	    // WRIST ROTATION //
	    ////////////////////
	    // Buttons: 7D (counterclockwise), 7U (clockwise)

	    if (vexRT[Btn7D] > 0) {
		rotateWristCounterClockwise();
	    } else if (vexRT[Btn7U] > 0) {
		rotateWristClockwise();
	    } else {
		stopRotatingWrist();
	    }

	    // PRECISION MODE
	    // While button 5U is held down, the robot's drive and wrist rotation motors slow by 50%.
	    if (vexRT[Btn5U] > 0) {
		precisionFactor = 0.5;
	    } else {
	      precisionFactor = 1.0;
	    }

	} // end (while true)
} // end (task usercontrol)
